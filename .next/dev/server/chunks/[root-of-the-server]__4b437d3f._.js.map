{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/wearebrain/Desktop/Manglar%20Media/adv_builder/xevio-adv-builder/lib/url-utils.ts"],"sourcesContent":["import { ReferenceUrl } from './types'\n\nexport type UrlChangeType = 'none' | 'additions_only' | 'structural'\n\nexport interface UrlChangeResult {\n  changeType: UrlChangeType\n  newUrls: string[]\n}\n\n/**\n * Normalize a URL for comparison by trimming whitespace and removing trailing slashes\n */\nfunction normalizeUrl(url: string): string {\n  return url.trim().replace(/\\/+$/, '').toLowerCase()\n}\n\n/**\n * Clean a URL for storage and sending: trim whitespace and strip trailing slashes.\n * Unlike normalizeUrl, this preserves the original casing (paths can be case-sensitive).\n */\nexport function cleanUrl(url: string): string {\n  return url.trim().replace(/\\/+$/, '')\n}\n\n/**\n * Extract URL strings from ReferenceUrl array\n */\nexport function extractUrls(referenceUrls: ReferenceUrl[]): string[] {\n  return referenceUrls\n    .map(ref => typeof ref === 'string' ? ref : ref?.url)\n    .filter((url): url is string => !!url && url.trim() !== '')\n    .map(normalizeUrl)\n}\n\n/**\n * Detect what type of URL changes occurred between current and scraped URLs\n * \n * @param currentUrls - Array of current URLs entered by user\n * @param scrapedUrls - Array of URLs that were previously scraped\n * @returns Object with changeType and array of new URLs (for additions_only case)\n * \n * Logic:\n * - 'none': Sets are identical, no changes needed\n * - 'additions_only': Current is a superset of scraped (only new URLs added)\n * - 'structural': URLs were deleted or modified, requires full re-scrape\n */\nexport function detectUrlChanges(\n  currentUrls: string[],\n  scrapedUrls: string[]\n): UrlChangeResult {\n  // Normalize all URLs for comparison\n  const currentSet = new Set(currentUrls.map(normalizeUrl))\n  const scrapedSet = new Set(scrapedUrls.map(normalizeUrl))\n\n  // If both are empty or identical, no changes\n  if (currentSet.size === 0 && scrapedSet.size === 0) {\n    return { changeType: 'none', newUrls: [] }\n  }\n\n  // Check if sets are identical\n  if (currentSet.size === scrapedSet.size) {\n    const allMatch = [...currentSet].every(url => scrapedSet.has(url))\n    if (allMatch) {\n      return { changeType: 'none', newUrls: [] }\n    }\n  }\n\n  // Check if all scraped URLs still exist in current (additions only)\n  const allScrapedStillExist = [...scrapedSet].every(url => currentSet.has(url))\n  \n  if (allScrapedStillExist) {\n    // Find new URLs (in current but not in scraped)\n    const newUrls = [...currentSet].filter(url => !scrapedSet.has(url))\n    \n    if (newUrls.length > 0) {\n      return { changeType: 'additions_only', newUrls }\n    }\n    \n    // No new URLs and all scraped exist = no changes\n    return { changeType: 'none', newUrls: [] }\n  }\n\n  // Some scraped URLs were removed or modified = structural change\n  return { changeType: 'structural', newUrls: [] }\n}\n\n/**\n * Compare two StepOneState objects to detect if there are meaningful changes\n * that would affect scraping (context-related fields)\n */\nexport function hasStepOneChanges(\n  current: { topic: string; niche: string; campaignType: string; country: string; language: string; guidelines: string },\n  original: { topic: string; niche: string; campaignType: string; country: string; language: string; guidelines: string } | null | undefined\n): boolean {\n  if (!original) return false\n  \n  // Compare fields that affect scraping context\n  return (\n    current.topic !== original.topic ||\n    current.niche !== original.niche ||\n    current.campaignType !== original.campaignType ||\n    current.country !== original.country ||\n    current.language !== original.language ||\n    current.guidelines !== original.guidelines\n  )\n}\n"],"names":[],"mappings":";;;;;;;;;;AASA;;CAEC,GACD,SAAS,aAAa,GAAW;IAC/B,OAAO,IAAI,IAAI,GAAG,OAAO,CAAC,QAAQ,IAAI,WAAW;AACnD;AAMO,SAAS,SAAS,GAAW;IAClC,OAAO,IAAI,IAAI,GAAG,OAAO,CAAC,QAAQ;AACpC;AAKO,SAAS,YAAY,aAA6B;IACvD,OAAO,cACJ,GAAG,CAAC,CAAA,MAAO,OAAO,QAAQ,WAAW,MAAM,KAAK,KAChD,MAAM,CAAC,CAAC,MAAuB,CAAC,CAAC,OAAO,IAAI,IAAI,OAAO,IACvD,GAAG,CAAC;AACT;AAcO,SAAS,iBACd,WAAqB,EACrB,WAAqB;IAErB,oCAAoC;IACpC,MAAM,aAAa,IAAI,IAAI,YAAY,GAAG,CAAC;IAC3C,MAAM,aAAa,IAAI,IAAI,YAAY,GAAG,CAAC;IAE3C,6CAA6C;IAC7C,IAAI,WAAW,IAAI,KAAK,KAAK,WAAW,IAAI,KAAK,GAAG;QAClD,OAAO;YAAE,YAAY;YAAQ,SAAS,EAAE;QAAC;IAC3C;IAEA,8BAA8B;IAC9B,IAAI,WAAW,IAAI,KAAK,WAAW,IAAI,EAAE;QACvC,MAAM,WAAW;eAAI;SAAW,CAAC,KAAK,CAAC,CAAA,MAAO,WAAW,GAAG,CAAC;QAC7D,IAAI,UAAU;YACZ,OAAO;gBAAE,YAAY;gBAAQ,SAAS,EAAE;YAAC;QAC3C;IACF;IAEA,oEAAoE;IACpE,MAAM,uBAAuB;WAAI;KAAW,CAAC,KAAK,CAAC,CAAA,MAAO,WAAW,GAAG,CAAC;IAEzE,IAAI,sBAAsB;QACxB,gDAAgD;QAChD,MAAM,UAAU;eAAI;SAAW,CAAC,MAAM,CAAC,CAAA,MAAO,CAAC,WAAW,GAAG,CAAC;QAE9D,IAAI,QAAQ,MAAM,GAAG,GAAG;YACtB,OAAO;gBAAE,YAAY;gBAAkB;YAAQ;QACjD;QAEA,iDAAiD;QACjD,OAAO;YAAE,YAAY;YAAQ,SAAS,EAAE;QAAC;IAC3C;IAEA,iEAAiE;IACjE,OAAO;QAAE,YAAY;QAAc,SAAS,EAAE;IAAC;AACjD;AAMO,SAAS,kBACd,OAAsH,EACtH,QAA0I;IAE1I,IAAI,CAAC,UAAU,OAAO;IAEtB,8CAA8C;IAC9C,OACE,QAAQ,KAAK,KAAK,SAAS,KAAK,IAChC,QAAQ,KAAK,KAAK,SAAS,KAAK,IAChC,QAAQ,YAAY,KAAK,SAAS,YAAY,IAC9C,QAAQ,OAAO,KAAK,SAAS,OAAO,IACpC,QAAQ,QAAQ,KAAK,SAAS,QAAQ,IACtC,QAAQ,UAAU,KAAK,SAAS,UAAU;AAE9C"}},
    {"offset": {"line": 126, "column": 0}, "map": {"version":3,"sources":["file:///Users/wearebrain/Desktop/Manglar%20Media/adv_builder/xevio-adv-builder/app/api/validate-url/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { cleanUrl } from '@/lib/url-utils'\n\nexport async function POST(request: Request) {\n  try {\n    const { url } = await request.json()\n\n    if (!url || typeof url !== 'string') {\n      return NextResponse.json({ reachable: false, error: 'No URL provided' }, { status: 400 })\n    }\n\n    const cleaned = cleanUrl(url)\n\n    try {\n      const parsed = new URL(cleaned)\n      if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {\n        return NextResponse.json({ reachable: false, error: 'URL must use HTTP or HTTPS' })\n      }\n    } catch {\n      return NextResponse.json({ reachable: false, error: 'Invalid URL format' })\n    }\n\n    const controller = new AbortController()\n    const timeout = setTimeout(() => controller.abort(), 10_000)\n\n    try {\n      let response = await fetch(cleaned, {\n        method: 'HEAD',\n        signal: controller.signal,\n        redirect: 'follow',\n        headers: { 'User-Agent': 'Mozilla/5.0 (compatible; URLValidator/1.0)' },\n      })\n\n      if (response.status === 405 || response.status === 403) {\n        response = await fetch(cleaned, {\n          method: 'GET',\n          signal: controller.signal,\n          redirect: 'follow',\n          headers: { 'User-Agent': 'Mozilla/5.0 (compatible; URLValidator/1.0)' },\n        })\n      }\n\n      clearTimeout(timeout)\n\n      const reachable = response.ok\n      return NextResponse.json({\n        reachable,\n        status: response.status,\n        error: reachable ? null : `URL returned status ${response.status}`,\n      })\n    } catch (fetchError: unknown) {\n      clearTimeout(timeout)\n\n      if (fetchError instanceof Error && fetchError.name === 'AbortError') {\n        return NextResponse.json({ reachable: false, error: 'Request timed out' })\n      }\n\n      return NextResponse.json({ reachable: false, error: 'URL is unreachable' })\n    }\n  } catch {\n    return NextResponse.json({ reachable: false, error: 'Validation failed' }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,EAAE,GAAG,EAAE,GAAG,MAAM,QAAQ,IAAI;QAElC,IAAI,CAAC,OAAO,OAAO,QAAQ,UAAU;YACnC,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,WAAW;gBAAO,OAAO;YAAkB,GAAG;gBAAE,QAAQ;YAAI;QACzF;QAEA,MAAM,UAAU,IAAA,iIAAQ,EAAC;QAEzB,IAAI;YACF,MAAM,SAAS,IAAI,IAAI;YACvB,IAAI,OAAO,QAAQ,KAAK,WAAW,OAAO,QAAQ,KAAK,UAAU;gBAC/D,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,WAAW;oBAAO,OAAO;gBAA6B;YACnF;QACF,EAAE,OAAM;YACN,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,WAAW;gBAAO,OAAO;YAAqB;QAC3E;QAEA,MAAM,aAAa,IAAI;QACvB,MAAM,UAAU,WAAW,IAAM,WAAW,KAAK,IAAI;QAErD,IAAI;YACF,IAAI,WAAW,MAAM,MAAM,SAAS;gBAClC,QAAQ;gBACR,QAAQ,WAAW,MAAM;gBACzB,UAAU;gBACV,SAAS;oBAAE,cAAc;gBAA6C;YACxE;YAEA,IAAI,SAAS,MAAM,KAAK,OAAO,SAAS,MAAM,KAAK,KAAK;gBACtD,WAAW,MAAM,MAAM,SAAS;oBAC9B,QAAQ;oBACR,QAAQ,WAAW,MAAM;oBACzB,UAAU;oBACV,SAAS;wBAAE,cAAc;oBAA6C;gBACxE;YACF;YAEA,aAAa;YAEb,MAAM,YAAY,SAAS,EAAE;YAC7B,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB;gBACA,QAAQ,SAAS,MAAM;gBACvB,OAAO,YAAY,OAAO,CAAC,oBAAoB,EAAE,SAAS,MAAM,EAAE;YACpE;QACF,EAAE,OAAO,YAAqB;YAC5B,aAAa;YAEb,IAAI,sBAAsB,SAAS,WAAW,IAAI,KAAK,cAAc;gBACnE,OAAO,gJAAY,CAAC,IAAI,CAAC;oBAAE,WAAW;oBAAO,OAAO;gBAAoB;YAC1E;YAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,WAAW;gBAAO,OAAO;YAAqB;QAC3E;IACF,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,WAAW;YAAO,OAAO;QAAoB,GAAG;YAAE,QAAQ;QAAI;IAC3F;AACF"}}]
}